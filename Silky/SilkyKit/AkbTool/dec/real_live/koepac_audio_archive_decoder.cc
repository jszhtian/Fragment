// Copyright (C) 2016 by rr-
//
// This file is part of arc_unpacker.
//
// arc_unpacker is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// arc_unpacker is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with arc_unpacker. If not, see <http://www.gnu.org/licenses/>.

#include "dec/real_live/koepac_audio_archive_decoder.h"
#include "algo/format.h"
#include "algo/range.h"
#include "enc/microsoft/wav_audio_encoder.h"
#include "io/memory_byte_stream.h"

using namespace au;
using namespace au::dec::real_live;

static const auto magic = "KOEPAC\x00\x00"_b;

namespace
{
    struct CustomArchiveMeta final : dec::ArchiveMeta
    {
        size_t sample_rate;
    };
}

static u16 koe_8bit_trans_tbl[256] =
{
    0x8000, 0x81FF, 0x83F9, 0x85EF, 0x87E1, 0x89CF, 0x8BB9, 0x8D9F,
    0x8F81, 0x915F, 0x9339, 0x950F, 0x96E1, 0x98AF, 0x9A79, 0x9C3F,
    0x9E01, 0x9FBF, 0xA179, 0xA32F, 0xA4E1, 0xA68F, 0xA839, 0xA9DF,
    0xAB81, 0xAD1F, 0xAEB9, 0xB04F, 0xB1E1, 0xB36F, 0xB4F9, 0xB67F,
    0xB801, 0xB97F, 0xBAF9, 0xBC6F, 0xBDE1, 0xBF4F, 0xC0B9, 0xC21F,
    0xC381, 0xC4DF, 0xC639, 0xC78F, 0xC8E1, 0xCA2F, 0xCB79, 0xCCBF,
    0xCE01, 0xCF3F, 0xD079, 0xD1AF, 0xD2E1, 0xD40F, 0xD539, 0xD65F,
    0xD781, 0xD89F, 0xD9B9, 0xDACF, 0xDBE1, 0xDCEF, 0xDDF9, 0xDEFF,
    0xE001, 0xE0FF, 0xE1F9, 0xE2EF, 0xE3E1, 0xE4CF, 0xE5B9, 0xE69F,
    0xE781, 0xE85F, 0xE939, 0xEA0F, 0xEAE1, 0xEBAF, 0xEC79, 0xED3F,
    0xEE01, 0xEEBF, 0xEF79, 0xF02F, 0xF0E1, 0xF18F, 0xF239, 0xF2DF,
    0xF381, 0xF41F, 0xF4B9, 0xF54F, 0xF5E1, 0xF66F, 0xF6F9, 0xF77F,
    0xF801, 0xF87F, 0xF8F9, 0xF96F, 0xF9E1, 0xFA4F, 0xFAB9, 0xFB1F,
    0xFB81, 0xFBDF, 0xFC39, 0xFC8F, 0xFCE1, 0xFD2F, 0xFD79, 0xFDBF,
    0xFE01, 0xFE3F, 0xFE79, 0xFEAF, 0xFEE1, 0xFF0F, 0xFF39, 0xFF5F,
    0xFF81, 0xFF9F, 0xFFB9, 0xFFCF, 0xFFE1, 0xFFEF, 0xFFF9, 0xFFFF,
    0x0000, 0x0001, 0x0007, 0x0011, 0x001F, 0x0031, 0x0047, 0x0061,
    0x007F, 0x00A1, 0x00C7, 0x00F1, 0x011F, 0x0151, 0x0187, 0x01C1,
    0x01FF, 0x0241, 0x0287, 0x02D1, 0x031F, 0x0371, 0x03C7, 0x0421,
    0x047F, 0x04E1, 0x0547, 0x05B1, 0x061F, 0x0691, 0x0707, 0x0781,
    0x07FF, 0x0881, 0x0907, 0x0991, 0x0A1F, 0x0AB1, 0x0B47, 0x0BE1,
    0x0C7F, 0x0D21, 0x0DC7, 0x0E71, 0x0F1F, 0x0FD1, 0x1087, 0x1141,
    0x11FF, 0x12C1, 0x1387, 0x1451, 0x151F, 0x15F1, 0x16C7, 0x17A1,
    0x187F, 0x1961, 0x1A47, 0x1B31, 0x1C1F, 0x1D11, 0x1E07, 0x1F01,
    0x1FFF, 0x2101, 0x2207, 0x2311, 0x241F, 0x2531, 0x2647, 0x2761,
    0x287F, 0x29A1, 0x2AC7, 0x2BF1, 0x2D1F, 0x2E51, 0x2F87, 0x30C1,
    0x31FF, 0x3341, 0x3487, 0x35D1, 0x371F, 0x3871, 0x39C7, 0x3B21,
    0x3C7F, 0x3DE1, 0x3F47, 0x40B1, 0x421F, 0x4391, 0x4507, 0x4681,
    0x47FF, 0x4981, 0x4B07, 0x4C91, 0x4E1F, 0x4FB1, 0x5147, 0x52E1,
    0x547F, 0x5621, 0x57C7, 0x5971, 0x5B1F, 0x5CD1, 0x5E87, 0x6041,
    0x61FF, 0x63C1, 0x6587, 0x6751, 0x691F, 0x6AF1, 0x6CC7, 0x6EA1,
    0x707F, 0x7261, 0x7447, 0x7631, 0x781F, 0x7A11, 0x7C07, 0x7FFF,
};

static s8 koe_ad_trans_tbl[256] =
{
    0x00, -0x01, 0x01, -0x02, 0x02, -0x03, 0x03, -0x04,
    0x04, -0x05, 0x05, -0x06, 0x06, -0x07, 0x07, -0x08,
    0x08, -0x09, 0x09, -0x0A, 0x0A, -0x0B, 0x0B, -0x0C,
    0x0C, -0x0D, 0x0D, -0x0E, 0x0E, -0x0F, 0x0F, -0x10,
    0x10, -0x11, 0x11, -0x12, 0x12, -0x13, 0x13, -0x14,
    0x14, -0x15, 0x15, -0x16, 0x16, -0x17, 0x17, -0x18,
    0x18, -0x19, 0x19, -0x1A, 0x1A, -0x1B, 0x1B, -0x1C,
    0x1C, -0x1D, 0x1D, -0x1E, 0x1E, -0x1F, 0x1F, -0x20,
    0x20, -0x21, 0x21, -0x22, 0x22, -0x23, 0x23, -0x24,
    0x24, -0x25, 0x25, -0x26, 0x26, -0x27, 0x27, -0x28,
    0x28, -0x29, 0x29, -0x2A, 0x2A, -0x2B, 0x2B, -0x2C,
    0x2C, -0x2D, 0x2D, -0x2E, 0x2E, -0x2F, 0x2F, -0x30,
    0x30, -0x31, 0x31, -0x32, 0x32, -0x33, 0x33, -0x34,
    0x34, -0x35, 0x35, -0x36, 0x36, -0x37, 0x37, -0x38,
    0x38, -0x39, 0x39, -0x3A, 0x3A, -0x3B, 0x3B, -0x3C,
    0x3C, -0x3D, 0x3D, -0x3E, 0x3E, -0x3F, 0x3F, -0x40,
    0x40, -0x41, 0x41, -0x42, 0x42, -0x43, 0x43, -0x44,
    0x44, -0x45, 0x45, -0x46, 0x46, -0x47, 0x47, -0x48,
    0x48, -0x49, 0x49, -0x4A, 0x4A, -0x4B, 0x4B, -0x4C,
    0x4C, -0x4D, 0x4D, -0x4E, 0x4E, -0x4F, 0x4F, -0x50,
    0x50, -0x51, 0x51, -0x52, 0x52, -0x53, 0x53, -0x54,
    0x54, -0x55, 0x55, -0x56, 0x56, -0x57, 0x57, -0x58,
    0x58, -0x59, 0x59, -0x5A, 0x5A, -0x5B, 0x5B, -0x5C,
    0x5C, -0x5D, 0x5D, -0x5E, 0x5E, -0x5F, 0x5F, -0x60,
    0x60, -0x61, 0x61, -0x62, 0x62, -0x63, 0x63, -0x64,
    0x64, -0x65, 0x65, -0x66, 0x66, -0x67, 0x67, -0x68,
    0x68, -0x69, 0x69, -0x6A, 0x6A, -0x6B, 0x6B, -0x6C,
    0x6C, -0x6D, 0x6D, -0x6E, 0x6E, -0x6F, 0x6F, -0x70,
    0x70, -0x71, 0x71, -0x72, 0x72, -0x73, 0x73, -0x74,
    0x74, -0x75, 0x75, -0x76, 0x76, -0x77, 0x77, -0x78,
    0x78, -0x79, 0x79, -0x7A, 0x7A, -0x7B, 0x7B, -0x7C,
    0x7C, -0x7D, 0x7D, -0x7E, 0x7E, -0x7F, 0x7F, -0x80,
};

bool KoepacAudioArchiveDecoder::is_recognized_impl(io::File &input_file) const
{
    return input_file.stream.seek(0).read(magic.size()) == magic;
}

std::unique_ptr<dec::ArchiveMeta> KoepacAudioArchiveDecoder::read_meta_impl(
    const Logger &logger, io::File &input_file) const
{
    const auto file_count = input_file.stream.seek(0x10).read_le<u32>();
    const auto sample_rate = input_file.stream.seek(0x18).read_le<u32>();
    input_file.stream.seek(0x20);
    auto meta = std::make_unique<CustomArchiveMeta>();
    meta->sample_rate = sample_rate ? sample_rate : 22050;
    for (const auto i : algo::range(file_count))
    {
        auto entry = std::make_unique<PlainArchiveEntry>();
        const auto file_id = input_file.stream.read_le<u16>();
        entry->size = input_file.stream.read_le<u16>();
        entry->offset = input_file.stream.read_le<u32>();
        entry->path = algo::format("sample%05d", file_id);
        meta->entries.push_back(std::move(entry));
    }
    return std::move(meta);
}

std::unique_ptr<io::File> KoepacAudioArchiveDecoder::read_file_impl(
    const Logger &logger,
    io::File &input_file,
    const dec::ArchiveMeta &m,
    const dec::ArchiveEntry &e) const
{
    const auto meta = static_cast<const CustomArchiveMeta*>(&m);
    const auto entry = static_cast<const PlainArchiveEntry*>(&e);

    input_file.stream.seek(entry->offset);

    std::vector<size_t> sizes;
    for (const auto i : algo::range(entry->size))
        sizes.push_back(input_file.stream.read_le<u16>());

    std::vector<u16> output;
    for (const auto size : sizes)
    {
        io::MemoryByteStream input_stream(input_file.stream, size);
        if (!size)
        {
            for (const auto i : algo::range(0x400))
                output.push_back(0);
        }
        else if (size == 0x400)
        {
            for (const auto i : algo::range(0x400))
            {
                const auto b = input_stream.read<u8>();
                output.push_back(koe_8bit_trans_tbl[b]);
            }
        }
        else
        {
            u8 d = 0;
            for (const auto i : algo::range(0x400 / 2))
            {
                u8 s = input_stream.read<u8>();
                if ((s + 1) & 0x0F)
                {
                    d -= koe_ad_trans_tbl[s & 0x0F];
                }
                else
                {
                    s >>= 4;
                    s &= 0x0F;
                    auto s2 = s;
                    s = input_stream.read<u8>();
                    s2 |= (s << 4) & 0xF0;
                    d -= koe_ad_trans_tbl[s2];
                }
                output.push_back(koe_8bit_trans_tbl[static_cast<u8>(d)]);

                s >>= 4;
                d -= (s + 1) & 0x0F
                    ? koe_ad_trans_tbl[s & 0x0F]
                    : koe_ad_trans_tbl[input_stream.read<u8>()];
                output.push_back(koe_8bit_trans_tbl[static_cast<u8>(d)]);
            }
        }
    }

    bstr samples(reinterpret_cast<const u8*>(output.data()), output.size() * 2);

    res::Audio audio;
    audio.channel_count = 1;
    audio.sample_rate = meta->sample_rate;
    audio.bits_per_sample = 16;
    audio.samples = samples;
    const auto encoder = enc::microsoft::WavAudioEncoder();
    return encoder.encode(logger, audio, entry->path);
}

static auto _
    = dec::register_decoder<KoepacAudioArchiveDecoder>("real-live/koepac");
